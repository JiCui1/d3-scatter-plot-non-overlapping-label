<html>
  <head>
    <script src="https://d3js.org/d3.v5.min.js"></script>
  </head>

  <body>
    <svg id="scatterplot" width="500" height="500"></svg>

    <script>
      // Toy data with 5 points
      let data = [
        {
          x: 50,
          y: 50,
          name: "James Bond",
        },
        {
          x: 55,
          y: 55,
          name: "James Bond",
        },
        {
          x: 60,
          y: 65,
          name: "James Bond",
        },
        {
          x: 130,
          y: 165,
          name: "James Bond",
        },
        {
          x: 130,
          y: 165,
          name: "James Bond",
        },
      ];

      let margins = {
        left: 60,
        right: 30,
        top: 30,
        bottom: 30,
      };

      let width = 500;
      let height = 500;
      let offset = 30;
      let domainwidth = width - margins.left - margins.right - offset;
      let domainheight = height - margins.top - margins.bottom - offset;

      // svg canvas
      let svg = d3
        .select("#scatterplot")
        .append("svg")
        .attr("width", width)
        .attr("height", height)
        .append("g")
        .attr(
          "transform",
          "translate(" + margins.left + "," + margins.top + ")"
        );

      // scaling data based on canvas width and height
      let x = d3.scaleLinear().domain([-50, 50]).range([0, domainwidth]);
      let y = d3.scaleLinear().domain([-50, 50]).range([domainheight, 0]);

      // placeholder for axis to be entered later
      svg
        .append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + y.range()[0] + ")");
      svg.append("g").attr("class", "y axis");

      // top bottom left right labels
      let xaxislabelbottom = "Order tolerant";
      let xaxislabeltop = "Chaos Tolerant";
      let yaxislabelleft = "Team Driven";
      let yaxislabelright = "Self Driven";

      svg
        .append("text")
        .attr("fill", "#414241")
        .attr("text-anchor", "end")
        .attr("x", width / 2)
        .attr("y", height - 45)
        .text(xaxislabelbottom);

      svg
        .append("text")
        .attr("fill", "#414241")
        .attr("text-anchor", "end")
        .attr("x", width / 2)
        .attr("y", -10)
        .text(xaxislabeltop);

      svg
        .append("text")
        .attr("fill", "#414241")
        .attr("text-anchor", "end")
        .attr("x", -170)
        .attr("y", -30)
        .attr("transform", "rotate(-90)")
        .text(yaxislabelleft);

      svg
        .append("text")
        .attr("fill", "#414241")
        .attr("text-anchor", "end")
        .attr("x", width / 2)
        .attr("y", -390)
        .attr("transform", "rotate(90)")
        .text(yaxislabelright);

      //creating axis
      let xAxis = d3.axisBottom().scale(x).tickPadding(3);
      let yAxis = d3.axisLeft().scale(y).tickPadding(3);

      //select placeholder axis and draw
      svg.selectAll("g.y.axis").call(yAxis);
      svg.selectAll("g.x.axis").call(xAxis);

      // quadrant grid: horizontal rules
      let hr_width = 410;
      svg
        .append("g")
        .attr("class", "qxgrid")
        .call(xAxis.tickFormat("").tickSize(hr_width).ticks(2));

      svg
        .select("g.qxgrid")
        .selectAll(".tick")
        .style("opacity", 0.4)
        .style("stroke", "#000");

      // quadrant grid: vertical rules
      let vr_length = -380;
      svg
        .append("g")
        .attr("class", "qygrid")
        .call(yAxis.tickFormat("").tickSize(vr_length).ticks(2));

      svg
        .select("g.qygrid")
        .selectAll(".tick")
        .style("opacity", 0.4)
        .style("stroke", "#000");

      let item = svg.selectAll("g .node").data(data, function (d) {
        return d.name;
      });

      //create group from data
      let itemGroup = item
        .enter()
        .append("g")
        .attr("class", "node")
        .attr("transform", function (d) {
          return "translate(" + x(d.x) + "," + y(d.y) + ")";
        });

      //drawing circle
      let circle_radius = 4;
      itemGroup
        .append("circle")
        .attr("r", circle_radius)
        .attr("class", "dot")
        .style("opacity", 0.6)
        .style("fill", "#000");

      // Creates force simulation that, when enabled, allows points to repel each other
      let sim = d3.forceSimulation(data);
      sim.force(
        "collision",
        d3.forceCollide((d) => d.r)
      ); // Repulsion force
      sim.force(
        "x_force",
        d3.forceX((d) => d.x)
      ); // Each point attacted to its center x and y
      sim.force(
        "y_force",
        d3.forceY((d) => d.y)
      );
      sim.on("tick", drawPlot); // Redraws scatterplot at every simulation "tick"

      // Uncomment both lines below lets simulation run forever with obvious movements
      // sim.alphaDecay(0); // Allows simulation to run forever, numerically
      // sim.velocityDecay(0); // Movements become obvious

      sim.stop(); // Simulation is off initially
      drawPlot(); // Draws scatterplot (points overlap as simulation is off)

      /**
       * Draws points and labels in scatterplot as described in data.
       * For points and labbels that are already drawn, update their locations,
       * using (updated) values in data.
       */
      function drawPlot() {
        let bg_rect = d3.select("#scatterplot").selectAll("rect").data(data);
        let labels = d3.select("#scatterplot").selectAll(".name").data(data);

        // For new points and labels (not drawn yet, e.g., when page loads), draw them
        bg_rect
          .enter()
          .append("rect")
          .attr("x", (d) => d.x + 10)
          .attr("y", (d) => d.y + 13)
          .attr("width", (d) => d.name.length * 10)
          .attr("height", 25)
          .attr("fill", "#000")
          .attr("fill-opacity", "0.5");

        labels
          .enter()
          .append("text")
          .text((d) => d.name)
          .attr("class", "name")
          .attr("x", (d) => d.x + 10)
          .attr("y", (d) => d.y)
          .attr("alignment-baseline", "middle") // Vertically align text with point
          .style("fill", "#fff")
          .style("font-family", "sans-serif")
          .style("font-size", "13px");

        // For existing points already drawn, update their locations,
        // using (updated) values in data
        bg_rect.attr("x", (d) => d.x).attr("y", (d) => d.y);
        labels
          // .text(d => d.x + ", " + d.y)
          .attr("x", (d) => d.x + 10)
          .attr("y", (d) => d.y + 13);
      }

      sim.force(
        "collision",
        d3.forceCollide((d) => 50)
      );

      sim.restart();
    </script>
  </body>
</html>
